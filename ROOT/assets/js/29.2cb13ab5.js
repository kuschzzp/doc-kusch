(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{491:function(e,a,t){"use strict";t.r(a);var s=t(10),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"强引用、软引用、弱引用和虚引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强引用、软引用、弱引用和虚引用"}},[e._v("#")]),e._v(" 强引用、软引用、弱引用和虚引用")]),e._v(" "),t("h2",{attrs:{id:"强引用-默认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强引用-默认"}},[e._v("#")]),e._v(" 强引用（默认）")]),e._v(" "),t("p",[e._v("Java中默认声明的就是强引用，比如:")]),e._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Teacher")]),e._v(" t "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Teacher")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nt "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("此时只要t指向Teacher对象，Teacher对象就不会被回收，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出 "),t("code",[e._v("OutOfMemoryError（OOM）")]),e._v(" ，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。")]),e._v(" "),t("h2",{attrs:{id:"软引用-softreference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#软引用-softreference"}},[e._v("#")]),e._v(" 软引用（SoftReference）")]),e._v(" "),t("p",[e._v("在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术。")]),e._v(" "),t("h2",{attrs:{id:"弱引用-weakreference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#弱引用-weakreference"}},[e._v("#")]),e._v(" 弱引用（WeakReference）")]),e._v(" "),t("p",[e._v("无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。")]),e._v(" "),t("h2",{attrs:{id:"虚引用-phantomreference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚引用-phantomreference"}},[e._v("#")]),e._v(" 虚引用（PhantomReference）")]),e._v(" "),t("p",[e._v("虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用 "),t("code",[e._v("java.lang.ref.PhantomReference")]),e._v(" 类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。"),t("br"),e._v("\n　　要注意的是，虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对`象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。")])])}),[],!1,null,null,null);a.default=r.exports}}]);