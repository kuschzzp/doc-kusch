---
title: 垃圾回收GC
date: 2023-05-13 23:25:11
permalink: /pages/b9f58a/
categories:
  - Java
  - JVM
tags:
  - JVM
author: 
  name: Mr.Kusch
  link: https://github.com/kuschzzp
---
### 一、垃圾回收（GC）是什么？

Java 是一门 **托管内存语言**，程序员不用手动释放对象内存，JVM 会自动回收无用对象，这个过程就是 **垃圾回收**。

**为什么需要 GC？**

* 避免内存泄漏和程序崩溃
* 简化开发，减少内存管理错误
* 优化内存利用率和程序性能

### 二、JVM内存与垃圾回收的关系

JVM内存（重点是堆内存）是 GC 的主战场，堆内存又分为：

| 区域                    | 说明                               |
| --------------------- | -------------------------------- |
| 新生代（Young Generation） | 新创建对象所在区域，分 Eden 区和两个 Survivor 区 |
| 老年代（Old Generation）   | 经历多次 GC 后存活的对象存放区                |
| 永久代 / 元空间             | 类元信息所在区域，GC 较少涉及                 |

垃圾回收主要针对**堆内存**的对象进行。

### 三、GC的基本原理

Java GC 基本思想是：

* **找出不可达对象（Dead Objects）并回收它们的内存**。
* 通过“根”（GC Roots）进行**可达性分析**：从 GC Roots 出发，所有可达的对象都是存活的，其他的就是垃圾。

**GC Roots 例子**：

* 虚拟机栈（栈帧中的本地变量）
* 方法区中的类静态属性
* 常量池中的引用
* 本地方法栈中的引用


### 四、Java 8 常见垃圾回收器

Java 8 默认使用 **Parallel GC**，它是多线程的年轻代垃圾回收器。除此之外，还有几种常用 GC：

| 垃圾回收器名称                     | 简介                                | 适用场景               |
| --------------------------- | --------------------------------- | ------------------ |
| Serial GC                   | 单线程 GC，简单高效，适合小内存环境               | 单核或低内存环境           |
| Parallel GC                 | 多线程 GC，关注吞吐量，适合后台批处理、大数据          | CPU 多核、追求吞吐量的应用    |
| CMS (Concurrent Mark Sweep) | 以最小停顿为目标，主要做并发标记和清理               | 低延迟应用，需要减少停顿时间     |
| G1 GC (Garbage First)       | 面向服务端、分代收集、区域划分，替代 CMS，兼顾吞吐量和响应时间 | 大内存、大堆，要求响应时间稳定的应用 |

### 五、垃圾回收的几个重要概念

1. **Minor GC（小GC）**
   主要回收新生代，速度快，停顿时间短。

    * 新生代内存满了触发
    * 将存活对象移到 Survivor 区，最终晋升到老年代

2. **Full GC（大GC）**
   回收整个堆（包括老年代和新生代），停顿时间较长。

    * 老年代满了，或永久代（元空间）满了触发
    * 一般由 CMS 或 G1 等回收器完成

3. **内存分配策略**

    * 大对象直接进入老年代
    * 长时间存活的对象晋升到老年代
    * 分代收集思想：新生代频繁回收，老年代少回收
    * 
### 六、GC调优的几个常用参数（Java 8）

| 参数名称                      | 作用                        | 示例                           |
| ------------------------- | ------------------------- | ---------------------------- |
| `-Xms` 和 `-Xmx`           | JVM 堆最小和最大内存              | `-Xms2g -Xmx2g`              |
| `-XX:NewRatio`            | 堆中新生代和老年代的比例，默认是 1:2      | `-XX:NewRatio=3` 表示老年代3倍于新生代 |
| `-XX:SurvivorRatio`       | 新生代中 Eden 区和 Survivor 区比例 | `-XX:SurvivorRatio=8`        |
| `-XX:+UseParallelGC`      | 使用并行 GC（年轻代和老年代都并行）       |                              |
| `-XX:+UseConcMarkSweepGC` | 使用 CMS GC                 |                              |
| `-XX:+UseG1GC`            | 使用 G1 GC                  |                              |
| `-XX:MaxGCPauseMillis`    | G1 GC 最大停顿时间目标            |                              |


### 七、java 8 之后新的垃圾收集器
在 JDK 8 之后，Java 引入了几款新的垃圾回收器，旨在满足现代应用对低延迟、高吞吐量和大内存支持的需求。以下是对这些新垃圾回收器的详细介绍：

#### 1. **ZGC（Z Garbage Collector）**

* **引入版本**：JDK 11（实验特性），JDK 15 正式发布
* **设计目标**：提供可扩展的低延迟垃圾回收，停顿时间通常不超过 10 毫秒，且与堆大小无关。
* **适用场景**：适用于大内存（8MB 至 4TB）且对延迟敏感的应用，如高频交易系统、实时数据处理等。
* **核心特性**：

    * **并发标记与回收**：绝大多数垃圾回收工作与应用线程并发执行，减少停顿时间。
    * **染色指针技术**：使用染色指针（colored pointers）追踪对象引用，避免全堆扫描，提高效率。
* **开启方式**：

```bash
  java -XX:+UseZGC -Xms4g -Xmx4g -jar yourapp.jar
```

#### 2. **Shenandoah GC**

* **引入版本**：JDK 12（实验特性），JDK 15 正式发布
* **设计目标**：提供低停顿的垃圾回收，适用于大内存应用。
* **适用场景**：适用于对停顿时间有严格要求的应用，如在线服务、实时数据处理等。
* **核心特性**：

    * **Region 分区**：堆被划分为多个小区域（Region），并发标记和重置只针对活跃区域，减少全堆扫描。
    * **并发压缩**：在应用线程运行时并发地压缩存活对象，避免单点停顿。
* **开启方式**：

```bash
  java -XX:+UseShenandoahGC -Xms4g -Xmx4g -jar yourapp.jar
```

#### 3. **G1 GC 的演进**

虽然 G1 GC 在 JDK 7 中引入，但在 JDK 9 至 JDK 11 期间进行了多项改进：

* **JDK 9**：G1 GC 成为默认垃圾回收器，取代 CMS。
* **JDK 10–11**：优化了并发标记阶段的吞吐量和并行度，减少混合回收停顿。
* **调优示例**：

```bash
  java -XX:+UseG1GC -Xms4g -Xmx4g -XX:MaxGCPauseMillis=200 -XX:InitiatingHeapOccupancyPercent=45 -jar yourapp.jar
```

* `-XX:MaxGCPauseMillis`：期望的最大停顿时间（毫秒）。
* `-XX:InitiatingHeapOccupancyPercent`：老年代占比多少时触发并发回收。([tech.meituan.com][1])

| GC 名称          | 引入版本      | 停顿特点        | 典型用途           |                      |
| -------------- | --------- | ----------- | -------------- | -------------------- |
| **Epsilon**    | JDK 11    | 无停顿（直接 OOM） | 性能测试、短期批处理     |                      |
| **ZGC**        | JDK 11+15 | ≤ 10 ms     | 超大堆、超低延迟场景     |                      |
| **Shenandoah** | JDK 12+15 | 可控低停顿       | 延迟敏感、需要并发压缩的应用 |                      |
| **G1** (演进)    | JDK 9–11  | 混合回收、较短停顿   | 大多数后端服务        | ([blog.csdn.net][2]) |