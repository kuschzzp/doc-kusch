---
title: JVM内存模型
date: 2023-05-13 23:21:18
permalink: /pages/d12a53/
categories:
  - Java
  - JVM
tags:
  - JVM
author: 
  name: Mr.Kusch
  link: https://github.com/kuschzzp
---
### 一、JVM 内存模型是什么？

JVM 内存模型（Java Memory Model，JMM）本质上描述了：

* Java 程序运行时，JVM 如何划分内存区域
* 各个内存区域的作用是什么
* 不同线程如何访问和操作这些内存区域

它是 Java 语言和多线程之间的“桥梁”，保证了程序运行时内存的安全和正确。

---

### 二、Java 8 JVM 内存模型主要有哪些区域？

Java 8 JVM 把运行时内存分为几个主要部分，每个部分都有不同的职责：

| 内存区域               | 作用                                                | 备注                              |
| ------------------ | ------------------------------------------------- | ------------------------------- |
| **程序计数器**          | 当前线程执行字节码的地址（类似指令指针）                              | 线程私有，大小固定，生命周期与线程相同             |
| **Java虚拟机栈**       | 存储方法的局部变量、操作数栈、动态链接、方法出口信息                        | 线程私有，大小可调                       |
| **本地方法栈**          | 支持本地方法调用的栈                                        | 线程私有                            |
| **堆（Heap）**        | 存放对象实例及数组，是 GC 管理的主要区域                            | 所有线程共享                          |
| **方法区（Metaspace）** | 存储类信息、常量、静态变量、即时编译器编译后的代码等，Java 8 以后改成了 Metaspace | 所有线程共享，Metaspace 在本地内存（Native）中 |
| **运行时常量池**         | 类的常量池，存放编译期生成的各种字面量和符号引用                          | 属于方法区的一部分                       |

---

### 三、Java 8 内存模型细节解析

#### 1. 程序计数器

* 每个线程独有，指示下一条要执行的字节码地址。
* 如果线程执行的是 native 方法，则计数器值为空。
* 它是线程私有的，所以不会有线程安全问题。

#### 2. Java 虚拟机栈

* 每个线程创建时都会创建一个虚拟机栈。
* 虚拟机栈用于存储栈帧（frame），每个方法调用对应一个栈帧。
* 栈帧中保存了局部变量、操作数栈、动态链接、返回地址等信息。
* 局部变量区：存放基本类型变量和对象引用（引用不是对象本身）。
* 当方法执行完成，栈帧被弹出，栈空间释放。

#### 3. 本地方法栈

* 和 Java 虚拟机栈类似，但它为本地方法服务（如调用 C/C++ 编写的本地代码）。

#### 4. 堆（Heap）

* 所有线程共享的内存区域。
* Java 中所有对象实例和数组都存储在这里。
* 垃圾回收器主要管理的区域。
* Java 8 将永久代（PermGen）移除，改为 Metaspace，堆只存放对象。

#### 5. 方法区（Metaspace）

* 以前的永久代在 Java 8 被移除，改用 Metaspace。
* Metaspace 存储类的元信息（类的结构、字段、方法、常量池等）。
* Metaspace 不再使用虚拟机内存，而是使用本地内存，默认大小更灵活。
* 过度使用 Metaspace 会导致本地内存溢出。

> Java 8 之前，类的元信息是存放在 永久代（PermGen） 中，这是 JVM 堆的一部分，大小有限且固定，容易导致内存溢出（OutOfMemoryError: PermGen space）。
> Java 8 以后，永久代被彻底移除，改用 Metaspace 来存储类的元信息。

| 优势                | 说明                                              |
| ----------------- | ----------------------------------------------- |
| **使用本地内存**        | Metaspace 不再使用虚拟机堆内存，而是使用本地（Native）内存，大小受系统内存限制 |
| **默认大小更灵活**       | 没有固定的初始大小（默认很大），避免了因永久代空间不足导致的频繁 Full GC        |
| **更少的内存管理压力**     | 由于依赖系统内存，垃圾回收器管理 Metaspace 压力小，减少了 Full GC 频率   |
| **动态调整**          | 可以动态调整大小，程序运行时按需申请内存                            |
| **减少内存溢出的风险**     | 以前永久代空间有限，容易溢出，Metaspace 更好地利用内存资源              |
| **支持更大规模的类加载和卸载** | 适合运行大量动态生成或频繁卸载类的应用（如热部署、插件机制）                  |

#### 6. 运行时常量池

* 属于方法区的一部分。
* 存储编译期生成的各种字面量和符号引用。
* 运行时常量池具有动态性，运行时可以将新的常量放入池中。

---

### 四、Java 内存模型中多线程内存交互的核心

JMM 规范了：

* **主内存**和**工作内存**的概念
* 各线程如何通过读取和写入主内存与自身工作内存交互
* **内存可见性**、**原子性**和**有序性**的保证方式

> 注意：这里的“主内存”并非堆的物理地址，而是抽象概念，表示所有线程共享的内存。

Java 内存模型用来解释多线程时，线程间变量共享的行为和一致性。
