---
title: 简述记录
date: 2024-03-18 15:05:18
permalink: /pages/e36655/
categories:
  - 对线
tags:
  -
author:
  name: Mr.Kusch
  link: https://github.com/kuschzzp
private: true     # 开启文章私密，必须
expire: 1d     # 登录状态超时清除时间，可选（不填则以全局超时时间为准，如果全局没有设置，则默认是一天）
---

## 汇总

### 单点登录

[单点登录](/pages/d3759d/)

所谓单点登录，就是在多应用系统当中，用户只需要登录一次，就可以访问所有相互信任的应用。

补充关于授权的话术：  

在门户系统支持注册应用，获得appid和secret，在应用下，维护各个应用的菜单权限。门户系统具有一个获取用户信息的接口，会返回该用户的权限数据。

### Redis缓存热点文章数据，缓存穿透、击穿、雪崩

- **存了什么内容？**

  缓存了 文章标签、文章分类树

- **发生变更如何保证数据库缓存一致性？**

  先更新数据库，再删除缓存

- **“先更新数据库，再删除缓存”这样一定不会出问题么？**

  还是有小几率出现问题的 例如：  
  &nbsp; &nbsp; &nbsp; &nbsp; 线程A 在缓存没有数据的情况下读取了 DB数据，还没来的及将数据写入缓存    
  &nbsp; &nbsp; &nbsp; &nbsp; 线程B 更新了数据，去删除缓存，并没有东西让它删除  
  &nbsp; &nbsp; &nbsp; &nbsp; 此时线程A才完成将数据写入缓存，那此时 缓存是老数据，DB是新数据。  
  由于缓存读写速率很快，一般情况下不会出现，线程B操作都执行完了，数据还没写入的情况。   
  应对这种情况可以给缓存设置合理的有效时间，这样仅会有一段不一致的时间。

- **你是如何解决击穿和穿透问题的？**

    - **击穿**指的是：客户端大量访问的一个极度热点数据key在某一时间失效，导致大量请求压倒数据库。通常两种解决方案：互斥锁、定时刷新。  
      1. 定时刷新策略，在小于过期时间的 时间点 去刷新缓存。
      2. 互斥锁，采用redis的 setnx(设置成功，返回 1 。 设置失败，返回 0 。) 命令。
         简要描述步骤：
         - *查询缓存，缓存不存在，获取锁，没获取到就等待后重新获取，获取到锁之后，查询数据库写入缓存，然后使用去释放锁(释放锁：LUA脚本或直接用redisson)。*（如果热点数据过期时间不太长，
           可以在获取到锁之后，再次查询缓存，存在就直接释放锁，不需要再查询数据库，这样可以保证只有一段时间内数据不一致。）  
    - **穿透**指的是：客户端访问大量的缓存与数据库都不存在的数据，导致数据库宕机。
      1. 将不存在的key缓存空对象
      2. 使用布隆过滤器（一定不存在 或者 可能存在）
      3. 接口限流，封ip
  
### 如何使用的 CompletableFuture 并行加载的统计数据 它有什么好处？

由于是需要获取统计结果的，所以原来选用的是 实现了 Runnable 接口的 FutureTask 类，它已经实现并行加载统计数据了，
但是Future.get() 就是阻塞调用，在线程获取结果之前get方法会一直阻塞。  
阻塞和异步编程相违背， 所以采用CompletableFuture，它提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方，节省CPU。


### MYSQL数据同步ES
常见的MySQL同步数据至ES的四种方案如下：

- 同步双写：在写入MySQL同时也向ES写入一份数据。
- 异步双写：接入MQ
- 定时任务
- 数据库订阅：例如canal


### Elasticsearch 



### ShardingSphere



### Nacos









