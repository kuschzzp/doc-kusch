---
title: Java与Mysql锁简述
date: 2024-03-05 13:33:55
permalink: /pages/83560c/
categories:
  - 对线
tags:
  - 对线
author:
  name: Mr.Kusch
  link: https://github.com/kuschzzp
---

## Java 中的锁

在多线程编程中，**锁（Lock）**是一种用于控制多个线程访问共享资源的同步机制。它的核心目的是**避免数据竞争（Race Condition）**和**保证数据一致性**。

### 1. 悲观锁（Pessimistic Lock）

悲观锁假定**并发访问一定会产生冲突**，因此在每次访问数据时都会“上锁”，保证同一时间只有一个线程能访问资源。

#### 实现方式

* **`synchronized` 关键字**：Java 内置关键字，基于对象监视器（Monitor）实现。
* **`ReentrantLock` 可重入锁**：JUC 包中提供的显式锁，功能更丰富（如公平锁、可中断锁、可定时锁等）。

#### 特点

* 优点：线程安全、实现简单。
* 缺点：阻塞等待，性能较低；可能出现**死锁**。
* 适用场景：**写操作频繁**、数据一致性要求高的场景。

#### 示例

```java
ReentrantLock lock = new ReentrantLock();
try {
    lock.lock();
    // 临界区：访问共享资源
} finally {
    lock.unlock();
}
```


### 2. 乐观锁（Optimistic Lock）

乐观锁假定**并发冲突很少发生**，因此不加锁直接操作资源，在提交更新时通过检查机制来判断数据是否被修改。

#### 实现方式

* **CAS（Compare-And-Swap）机制**：比较内存中的值是否为预期值，若一致则更新，否则重试。
* **版本号机制（Versioning）**：更新数据时比较版本号是否一致，不一致则回滚或重试。

#### Java 实现

JUC 包中的 `AtomicInteger`、`AtomicLong`、`AtomicReference` 等类，都是基于 **CAS 实现的无锁机制**。

```java
AtomicInteger count = new AtomicInteger(0);
count.compareAndSet(0, 1); // CAS 操作
```

#### 特点

* 优点：性能高，不会阻塞线程。
* 缺点：存在 **ABA 问题**（值改了又改回来），需要配合版本号解决。
* 适用场景：**读多写少**的高并发场景。

#### 解决 ABA 问题

JUC 提供了 `AtomicStampedReference`，在 CAS 基础上增加时间戳（版本号）：

```java
AtomicStampedReference<Integer> ref = new AtomicStampedReference<>(1, 0);
```

## MySQL 中的锁

在数据库中，锁用于控制多个事务对共享数据的并发访问，防止出现数据不一致问题。

MySQL 中的锁主要分为两类：

### 1. 表级锁（Table Lock）

* 对整张表加锁。
* 加锁速度快，不容易出现死锁。
* 并发性能低。

#### 特点

* **MyISAM**：只支持表级锁。
* **InnoDB**：在特定情况下也可能使用表级锁（如全表扫描）。


### 2. 行级锁（Row Lock）

* 针对具体数据行加锁。
* 并发性能高，但开销大、容易产生死锁。
* **仅 InnoDB 支持**。

> ⚠️ 注意：
> 若 `WHERE` 条件**没有命中索引**或索引失效，行锁会**退化为表锁**！

#### 示例

```sql
-- 如果 id 是主键索引，则只锁定一行
UPDATE user SET balance = balance - 100 WHERE id = 1;

-- 如果 id 没有索引，则会锁全表！
UPDATE user SET balance = balance - 100 WHERE name = 'Tom';
```


### 3. InnoDB 行级锁类型

| 锁类型                    | 说明            | 示例/用途           |
| :--------------------- | :------------ | :-------------- |
| **记录锁（Record Lock）**   | 锁住单行记录        | 锁定 id=10 的行     |
| **间隙锁（Gap Lock）**      | 锁住某个范围，不含边界记录 | 防止插入导致幻读        |
| **临键锁（Next-Key Lock）** | 记录锁 + 间隙锁     | 锁定行本身及相邻间隙，防止幻读 |

#### 锁行为说明

* 在 **可重复读（REPEATABLE READ）** 隔离级别下，InnoDB 默认使用**临键锁**来防止幻读。
* 若操作的是**唯一索引或主键**，InnoDB 会**优化为记录锁**（只锁住目标行）。














