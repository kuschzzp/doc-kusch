---
title: 简述技术点记录
date: 2024-03-18 15:05:18
permalink: /pages/e36655/
categories:
  - 对线
tags:
  - 对线
author:
  name: Mr.Kusch
  link: https://github.com/kuschzzp
private: true     # 开启文章私密，必须
expire: 1d     # 登录状态超时清除时间，可选（不填则以全局超时时间为准，如果全局没有设置，则默认是一天）
---

## 介绍

```text
Java和Python开发经验，主要从事企业级应用开发及AI智能体系统的研发工作。

在技术方面
我熟练掌握Java语言， 包括并发编程、线程池和常用设计模式，
熟悉Spring、Spring Boot、Spring Cloud等框架，
具备扎实的面向对象设计和编码能力。
同时，我熟练使用MySQL、Redis等数据库和缓存中间件，
并了解消息队列技术，具备并发编程、服务部署运维及系统设计与性能优化经验。

在项目经验方面
我参与过多个企业级系统和AI智能体项目：
RAG企业智能知识库系统：我负责设计和搭建模块化RAG全流程，涵盖文档加载、向量化、检索及AI Agent功能开发，并完成商业SAAS化改造和Docker Swarm容器化部署，实现高可用与弹性扩展。
AI测试用例生成系统：我基于Java和Python开发两版系统，利用大模型API生成测试用例，大幅提升测试效率，同时实现了Docker部署和CI/CD流水线自动化。
体育场馆智能平台及综合公文管理系统：我负责后台接口开发、Redis缓存优化、微服务组件化开发，并实现单点登录和高性能数据处理。

此外，我对AI Agent技术充满热情，熟悉RAG、LangChain、Prompt Engineering等大模型工具开发技术，能够快速搭建智能体平台，并将前沿AI技术应用到企业级场景中。
```

## 一、单点登录（SSO）与用户认证中心

知识点说明：
单点登录（Single Sign-On，SSO）是一种集中式身份认证机制，用于在多系统架构中让用户只需登录一次即可访问所有子系统。
核心思想：

1. 认证中心（Auth Server） 负责用户登录、签发凭证（如 JWT Token 或 Session ID）。
2. 子系统（Client App） 在访问时携带 Token，由网关或认证中心验证有效性。
3. 统一授权与权限管理：在认证中心维护应用注册信息（appId/secret）及角色菜单数据。
4. 缓存与可用性：用户信息与 Token 状态存储至 Redis，防止认证中心宕机影响业务系统。

项目举例（体育场馆智能平台）：
为 CRM、赛事、会员等多个子系统统一接入 SSO：

* 采用 Spring Security + OAuth2 实现认证授权，签发 JWT Token；
* Gateway 层统一过滤器验证 Token 并解析用户权限；
* 用户菜单、角色缓存到 Redis 中，系统即便在认证服务维护时也可正常访问；
* 门户系统支持应用注册，生成 appid 和 secret，用于应用鉴权和 API 调用。

可能问题：

1. 你项目中 SSO 是如何实现的？
2. 如果认证中心挂掉，系统如何保证可用？
3. 用户权限数据是如何管理和缓存的？

参考答案：

* 使用 OAuth2 授权码模式 + JWT 实现统一认证。认证中心发放 Token，子系统使用 Token 校验身份。
* Redis 存储用户权限缓存与登录态，即使 Auth Server 暂时宕机，系统仍能通过缓存认证。
* 用户权限信息（菜单、角色）在首次登录时缓存至 Redis，并设置过期时间定期刷新。



## 二、Redis 缓存一致性与高并发场景问题（穿透、击穿、雪崩）

知识点说明：
Redis 在高并发系统中承担着“数据加速层”的作用。
缓存使用不当会导致三大典型问题：

* 缓存穿透：请求的数据不存在，缓存与数据库都未命中。
* 缓存击穿：热点数据在同一时间失效，导致大量请求打到数据库。
* 缓存雪崩：大量缓存数据同时过期，引发数据库瞬时压力暴涨。

缓存与数据库一致性常见方案：

1. 先更新数据库，再删除缓存（推荐）；
2. 延时双删策略：更新数据库 → 删除缓存 → 延时再删一次缓存；
3. 对一致性要求极高的业务，可考虑消息队列异步同步。

项目举例（体育场馆智能平台）：
CRM 客户数据与热门统计模块使用 Redis 进行缓存：

* 采用“更新数据库后删除缓存”策略，保证数据一致性；
* 使用 Redisson 分布式锁防止热点 Key 击穿；
* 对查询量大但变更频率低的接口设置随机过期时间，避免缓存雪崩。

可能问题：

1. 为什么选择“先更新数据库再删除缓存”？
2. 如何处理缓存击穿与穿透？
3. 如果缓存与数据库不一致怎么办？

参考答案：

* 删除缓存比更新缓存更安全，防止并发写时缓存被旧数据覆盖；
* 缓存击穿：采用分布式锁，保证只有一个线程重建缓存；
* 缓存穿透：缓存空对象或布隆过滤器过滤非法请求；
* 缓存雪崩：给 key 添加随机过期时间，避免同时失效；
* 对短期不一致情况，可容忍，依赖 TTL 自动恢复。

示例：

```java
String key = "hot:article";
String val = redis.get(key);
if (val == null) {
    if (redis.setIfAbsent("lock:" + key, "1", 10, TimeUnit.SECONDS)) {
        try {
            val = db.query();
            redis.set(key, val, 5, TimeUnit.MINUTES);
        } finally {
            redis.delete("lock:" + key);
        }
    } else {
        Thread.sleep(50);
        val = redis.get(key);
    }
}
```



## 三、CompletableFuture 并行统计与异步优化

知识点说明：
`CompletableFuture` 是 Java8 提供的异步编程工具类，支持非阻塞式任务执行和任务结果合并。
优点：

* 支持任务依赖与组合（thenApply、thenCombine、allOf 等）；
* 避免主线程阻塞，提高 CPU 利用率；
* 适合数据汇总、统计、并行计算等业务场景。

项目举例（体育场馆智能平台 CRM 模块）：
首页统计接口需要汇总客户数量、订单数、积分排名等信息。

* 原始实现：串行查询数据库（耗时 1.8s）；
* 优化后：使用 `CompletableFuture` 并行执行多个统计任务，整体响应降至 300ms；
* 异常处理使用 `exceptionally`，防止部分任务失败导致全局阻塞。

可能问题：

1. CompletableFuture 与 FutureTask 的区别？
2. 你是如何让多个统计接口并行执行的？
3. 如果其中一个任务异常怎么办？

参考答案：

* FutureTask 调用 `get()` 会阻塞主线程，CompletableFuture 可链式组合并非阻塞；
* 使用 `CompletableFuture.allOf()` 等待全部完成；
* 使用 `exceptionally` 捕获异常，不影响其他任务执行。

示例：

```java
CompletableFuture<Integer> userCount = CompletableFuture.supplyAsync(() -> crmService.countUsers());
CompletableFuture<Integer> orderCount = CompletableFuture.supplyAsync(() -> crmService.countOrders());
CompletableFuture<Integer> scoreRank = CompletableFuture.supplyAsync(() -> crmService.topScores());
CompletableFuture.allOf(userCount, orderCount, scoreRank).join();

return Map.of(
    "userCount", userCount.join(),
    "orderCount", orderCount.join(),
    "scoreRank", scoreRank.join()
);
```



## 四、Spring 事务机制

知识点说明：
Spring 的事务机制通过 AOP 代理方式实现，支持七种传播行为和五种隔离级别。
核心目的是保证操作的原子性、一致性、隔离性、持久性（ACID）。

* 默认传播行为：`REQUIRED`（支持当前事务，无则新建）
* 默认隔离级别：数据库默认（MySQL 是 REPEATABLE_READ）
* 常见事务失效场景：方法非 `public`、自调用、异常未抛出或被捕获。

项目举例（综合公文管理系统）：

* 批量插入公文数据时采用 `@Transactional` 确保一致性；
* 针对分表写入逻辑，事务内调用异步任务时，采用编程式事务管理，防止异步线程不受事务控制；
* 异步任务中手动使用 `TransactionTemplate` 保证数据回滚。

可能问题：

1. 事务传播行为有哪些？
2. Spring 事务为什么可能失效？
3. 数据库与 Spring 事务的隔离级别不一致会怎样？

参考答案：

* 传播行为：REQUIRED、REQUIRES_NEW、NESTED、SUPPORTS 等。
* 失效原因：方法非 public、自调用、异常被捕获。
* 若配置为 `Isolation.DEFAULT`，则以数据库设置为准，否则以 Spring 为准。



## 五、MySQL 数据同步 Elasticsearch

知识点说明：
ES 适合高性能搜索与分析场景，MySQL 与 ES 数据同步常见 4 种方式：

1. 同步双写（简单但一致性差）；
2. 异步双写（经 MQ）；
3. 定时任务同步；
4. Canal 监听 binlog 实时同步（推荐）。

项目举例（综合公文管理系统）：

* 公文数据量 600 万条，采用 MySQL+ES 架构；
* 定时任务（XXL-Job）负责差异同步；
* 根据业务数据变动量，采用异步线程池提高同步效率。

可能问题：

1. 你项目中如何保证 MySQL 与 ES 数据一致？
2. 为什么不直接双写？
3. Canal 的原理是什么？

参考答案：

* 使用定时任务扫描变更表，异步写入 ES；
* 双写容易造成失败不一致问题；
* Canal 通过伪装成 MySQL Slave 解析 binlog 实现实时同步。



## 六、Nacos 配置中心与服务治理

知识点说明：
Nacos 提供配置管理、服务注册与发现功能。
特性：

* 支持配置热更新（`@RefreshScope`）
* 支持命名空间隔离与多环境管理
* 支持集群部署与心跳健康检测

项目举例（微服务 Starter 组件平台）：

* 各服务统一接入 Nacos 配置中心；
* 使用监听机制实现权限菜单实时刷新；
* 替换 Apollo 后显著降低配置变更延迟。

可能问题：

1. 配置更新是如何感知的？
2. Nacos 与 Apollo 区别？
3. 如何避免配置更新导致服务不稳定？

参考答案：

* 客户端通过长轮询机制感知配置变化；
* Apollo 采用主动拉取，Nacos 推拉结合；
* 关键配置需灰度发布，或使用命名空间隔离测试环境。



## 七、Redis 分布式锁

知识点说明：
分布式锁用于保证多实例间对共享资源的互斥访问。
实现方式：

* 基于 Redis：`SET key value NX PX expire` 原子命令。
* 释放锁：Lua 脚本校验锁标识，防止误删。
* Redisson：封装重入锁、续期（看门狗）机制。

项目举例（订票系统）：

* 使用 Redisson 加锁防止多用户同时抢票导致超卖；
* 对库存采用分段锁方案，提高并发性能；
* 结合异步 MQ 实现削峰填谷。

可能问题：

1. setnx 实现分布式锁的关键是什么？
2. 为什么释放锁要用 Lua 脚本？
3. Redisson 相比手写锁的优势？

参考答案：

* 关键是 `NX` 保证原子性，`PX` 设过期防死锁；
* Lua 脚本校验锁 value 防误删；
* Redisson 支持重入、自动续期（看门狗）、公平锁。


## 八、RAG 企业智能知识库系统（AI Agent 平台）

知识点说明：
RAG（Retrieval-Augmented Generation）通过检索 + 生成模式提升大模型问答的准确性与可溯源性。
流程：

1. 文档加载与分片；
2. 向量化存储（如 FAISS / Milvus / ElasticSearch）；
3. 检索召回相关片段；
4. 拼接上下文后调用 LLM 生成回答。

项目举例（RAG企业智能知识库系统）：

* 使用 Flask + ES + Docker 构建多租户 RAG 平台；
* 向量化文本检索结合阿里百炼大模型实现精准问答；
* 支持自定义 Agent（如会议总结、文档问答、长文生成）；
* 使用 Traefik + Swarm 实现多实例容器化部署。

可能问题：

1. RAG 的核心流程是什么？
2. 检索阶段如何提高准确率？
3. Agent 是如何封装任务的？

参考答案：

* 流程：加载文档 → 向量化 → 检索 → 拼接上下文 → 模型生成 → 引用回溯；
* 优化召回：使用嵌入模型（bge-m3 / text-embedding-3-large）+ 向量重排序；
* Agent 封装复杂任务链路（如知识库问答 → 内容生成 → 答案校验），通过配置 Prompt 与工作流节点自动化执行。


## 九、Spring Cloud 微服务架构实战篇

知识点说明: 

Spring Cloud 是构建分布式微服务体系的核心框架，基于 Spring Boot 扩展一整套基础设施，提供了：

* 服务注册与发现（Nacos / Eureka）
* 客户端负载均衡（Ribbon / LoadBalancer）
* 服务间调用（Feign）
* 网关路由与统一鉴权（Gateway）
* 配置中心（Nacos / Apollo）
* 熔断与限流（Sentinel）
* 分布式事务（Seata）
* 任务调度（XXL-Job / Power-Job）

核心设计思想：

> 微服务架构的关键不是拆分，而是“治理”。Spring Cloud 通过一系列基础组件解决了服务发现、配置管理、限流熔断、链路追踪、灰度发布等问题。



### 项目举例（体育场馆智能平台）

该平台包含多个子系统（CRM、赛事、会员、物联网、运营中心等），采用 Spring Cloud + Nacos + Feign + Gateway 实现服务治理。

实现要点：

1. 服务注册与发现
   各模块（crm-service、order-service、member-service）启动时自动注册到 Nacos；
   Gateway 根据服务名动态路由请求。

   ```yaml
   spring:
     cloud:
       nacos:
         discovery:
           server-addr: nacos:8848
       gateway:
         routes:
           - id: crm
             uri: lb://crm-service
             predicates:
               - Path=/crm/
   ```

2. 服务调用（Feign）
   服务间通过 Feign 调用，简化 HTTP 通信：

   ```java
   @FeignClient(name = "order-service")
   public interface OrderClient {
       @GetMapping("/order/user/{id}")
       OrderDTO getOrderByUserId(@PathVariable Long id);
   }
   ```

    * 使用 `@EnableFeignClients` 启用；
    * 开启 Feign + Sentinel 整合进行熔断保护。

3. 统一网关（Gateway）

    * 所有请求经过 Gateway，进行统一认证（JWT 校验）；
    * 自定义全局过滤器在 Header 中传递用户信息；
    * 支持动态路由与限流。

4. 熔断与限流（Sentinel）

    * 对热点接口配置 QPS 限流；
    * 为 Feign 客户端配置降级逻辑；

   ```java
   @Component
   public class OrderFallback implements FallbackFactory<OrderClient> {
       @Override
       public OrderClient create(Throwable cause) {
           return id -> new OrderDTO("fallback", "服务降级");
       }
   }
   ```

5. 分布式事务（Seata）

    * 在会员购买积分、生成订单、更新库存等跨服务场景中使用 Seata AT 模式；
    * TC 服务由独立部署，TM 与 RM 嵌入微服务中；

   ```java
   @GlobalTransactional(name = "order-create", rollbackFor = Exception.class)
   public void createOrder() {
       memberClient.updatePoints();
       orderMapper.insert(order);
       stockClient.decrease();
   }
   ```

6. 配置中心（Nacos）

    * 各服务配置分环境（dev/test/prod）；
    * 实现动态刷新（`@RefreshScope`）；
    * 敏感配置（如 DB 密码）使用加密存储。



### 项目举例（微服务 Starter 组件平台）

该项目旨在构建可复用微服务组件，简化企业级服务开发。

核心特性：

1. 组件化封装

    * 基于 Spring Boot Starter 形式封装公共能力：

        * 日志组件（AOP 切面记录接口耗时与入参）
        * 扫码登录组件（OAuth2 协议实现）
        * 缓存组件（Redis 封装）
    * 提供统一的 `starter-*` 模块，其他微服务直接引入即可使用。

2. 实时权限刷新

    * 基于 Nacos 配置监听，当管理员更新菜单权限时触发监听器；
    * 实时刷新 Redis 缓存中的用户权限。

   ```java
   @NacosConfigListener(dataId = "menu-config.yaml", timeout = 5000)
   public void refreshMenu(String config) {
       permissionService.refresh(config);
   }
   ```

3. OAuth2 授权服务

    * 基于 `spring-authorization-server` 构建 OAuth2 Server；
    * 提供密码模式、客户端模式两种认证；
    * 支持 Token 续签与刷新；
    * 结合 Gateway 实现统一鉴权入口。

可能问题

1. Spring Cloud 中服务注册和发现的原理是什么？
2. Feign 调用失败后如何进行降级处理？
3. Gateway 如何实现统一认证与权限控制？
4. Sentinel 的限流与熔断规则有哪些？
5. Seata 是如何实现分布式事务的？
6. 如何实现微服务配置热更新？

参考答案（含示例与原理）

- 服务注册与发现

* 每个微服务在启动时将自身信息（IP、端口、健康状态）注册到 Nacos；
* Gateway 或其他服务通过 Nacos 拉取最新注册表实现动态调用；
* 心跳机制保持注册状态，Nacos 自动剔除无效实例。

- Feign 降级与容错

* Feign + Sentinel 整合实现服务降级；
* 当下游服务不可用时，自动调用 fallback 实例，避免请求失败；
* 可以在控制台配置限流或自定义熔断逻辑。

- Gateway 统一认证

* 所有请求先经过 Gateway；
* 在全局过滤器中解析 JWT，校验用户权限；
* 若 Token 失效则返回 401；
* Header 中传递用户信息供下游服务使用。

示例：

```java
@Component
public class AuthGlobalFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String token = exchange.getRequest().getHeaders().getFirst("Authorization");
        if (!validateToken(token)) {
            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
            return exchange.getResponse().setComplete();
        }
        return chain.filter(exchange);
    }
}
```

- Sentinel 限流熔断

* 支持三种模式：QPS 限流、线程数控制、熔断降级；
* 可在控制台或注解方式配置；
* 熔断规则基于异常比例、异常数、响应时间等维度触发。

- Seata 分布式事务原理

* AT 模式基于数据源代理拦截 SQL；
* TC（事务协调器）记录全局事务；
* RM（资源管理器）负责分支事务提交/回滚；
* TM（事务管理器）发起全局事务；
* 每个分支事务的 UndoLog 记录本地回滚点。

- 配置热更新

* 启动时指定 Nacos 配置文件：

  ```yaml
  spring:
    cloud:
      nacos:
        config:
          server-addr: nacos:8848
          group: DEFAULT_GROUP
          data-id: crm-service.yaml
  ```
* 通过 `@RefreshScope` 注解标记配置类；
* 当 Nacos 中配置变更时，客户端自动刷新属性值。





