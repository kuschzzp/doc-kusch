---
title: Dockerfile常用语法
date: 2023-05-13 23:12:11
permalink: /pages/afcf79/
categories:
  - 部署与运维
  - Docker部署
tags:
  - 随笔
author: 
  name: Mr.Kusch
  link: https://github.com/kuschzzp
---

# Dockerfile

## 1. Dockerfile 基础概念

**Dockerfile** 是一个文本文件，其中包含了一系列指令，用于告诉 Docker 如何构建一个镜像。每一条指令都是对镜像的一层修改，最终生成你需要的镜像。

### 常用 Dockerfile 指令

| 指令           | 功能                             | 示例                                              |
| ------------ | ------------------------------ | ----------------------------------------------- |
| `FROM`       | 指定基础镜像                         | `FROM ubuntu:22.04`                             |
| `RUN`        | 在镜像中执行命令                       | `RUN apt-get update && apt-get install -y curl` |
| `CMD`        | 容器启动时执行的命令（默认命令，可被覆盖）          | `CMD ["echo", "Hello Docker"]`                  |
| `ENTRYPOINT` | 容器启动时执行的命令（不易被覆盖）              | `ENTRYPOINT ["python3", "app.py"]`              |
| `COPY`       | 将文件/目录从主机复制到镜像                 | `COPY ./app /app`                               |
| `ADD`        | 类似 COPY，但支持 URL 下载和自动解压 tar 文件 | `ADD https://example.com/file.tar.gz /tmp/`     |
| `WORKDIR`    | 设置工作目录                         | `WORKDIR /app`                                  |
| `ENV`        | 设置环境变量                         | `ENV APP_ENV=production`                        |
| `EXPOSE`     | 声明容器监听的端口（不实际打开端口）             | `EXPOSE 8080`                                   |
| `VOLUME`     | 定义卷                            | `VOLUME /data`                                  |
| `USER`       | 指定运行用户                         | `USER appuser`                                  |

---

## 2. Dockerfile 构建流程理解

1. Docker 从 `FROM` 指令开始，获取基础镜像。
2. 每一条指令都会创建镜像的一层（Layer）。
3. 每一层可以被缓存，减少重复构建时间。
4. 最后一条 `CMD` 或 `ENTRYPOINT` 指令指定容器启动行为。

---

## 3. 编写简单 Dockerfile 示例

假设我们有一个 Python 应用：

目录结构：

```
myapp/
 ├─ app.py
 ├─ requirements.txt
```

### 示例 Dockerfile

```dockerfile
# 使用官方 Python 镜像作为基础
FROM python:3.11-slim

# 设置工作目录
WORKDIR /app

# 将依赖文件复制到镜像
COPY requirements.txt .

# 安装依赖
RUN pip install --no-cache-dir -r requirements.txt

# 将应用代码复制到镜像
COPY app.py .

# 暴露端口
EXPOSE 5000

# 启动应用
CMD ["python", "app.py"]
```

### 构建与运行

```bash
# 构建镜像
docker build -t myapp:latest .

# 运行容器
docker run -p 5000:5000 myapp:latest
```

---

## 4. Dockerfile 编写最佳实践

1. **减少镜像体积**

    * 使用轻量基础镜像（如 `alpine` 或 `slim`）。
    * 合并 RUN 指令，减少镜像层数。
    * 使用 `--no-cache` 或 `--rm` 清理临时文件。

   ```dockerfile
   RUN apt-get update && apt-get install -y curl \
       && rm -rf /var/lib/apt/lists/*
   ```

2. **利用缓存**

    * 将变化不频繁的步骤放在前面。
    * 例如依赖安装步骤在复制应用代码之前。

3. **明确环境**

    * 使用 `ENV` 指定环境变量，方便配置。

4. **安全性**

    * 避免以 root 用户运行应用，使用 `USER` 指令切换用户。
    * 不在镜像中存放敏感信息，如密码。

---

## 5. 高级技巧

* 多阶段构建（Multi-stage Build）：减少最终镜像体积，常用于编译语言或打包前端资源。

```dockerfile
# 构建阶段
FROM node:20 AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# 生产阶段
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

* 动态参数：使用 `ARG` 指令在构建时传递变量。

```dockerfile
ARG VERSION=latest
FROM myimage:${VERSION}
```