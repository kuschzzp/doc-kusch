---
title: Agent定义
date: 2025-11-12 15:48:14
permalink: /pages/0daf45/
categories:
  - 强大的AI
  - Agent
tags:
  - Agent
author: 
  name: Mr.Kusch
  link: https://github.com/kuschzzp
---
## Agent与Workflow
要理解 **Agent** 首先要理解传统形式的 **Workflow**。

通过阅读 anthropic 的文章[Building effective agents](https://www.anthropic.com/engineering/building-effective-agents)，可以理解到：

1. Workflows are systems where LLMs and tools are orchestrated through predefined code paths.

> 工作流是通过预定义的代码路径来编排大型语言模型（LLMs）和工具的系统。
>

2. Agents, on the other hand, are systems where LLMs dynamically direct their own processes and tool usage, maintaining control over how they accomplish tasks.

> Agents是指这样一类系统：在这些系统中，大语言模型（LLMs）动态地指导自己的流程和工具使用，保持对如何完成任务的控制。
>

### 何时使用 Agent系统及何时不使用
在使用大语言模型（LLM）构建应用程序时，我们建议尽可能寻找最简单的解决方案，只有在需要时才增加复杂性。这可能意味着根本不构建 Agent 系统。Agent 系统通常在提高任务性能的同时，牺牲了延迟和成本，因此你应该在考虑这种权衡时，评估它是否合理。

当需要更多复杂性时，工作流能够为定义明确的任务提供可预测性和一致性，而当需要灵活性和基于模型的决策制定时，Agent 是更好的选择。然而，对于许多应用程序来说，通过检索和上下文示例来优化单一的 LLM 调用通常就足够了。

| 维度 | Workflow | Agent |
| -- | --- | --- |
| 结构 | 固定、可预测 | 自主、动态 |
| 任务拆分 | 任务被明确分解成子任务，顺序固定 | Agent 自己根据输入和环境决定下一步要做什么、调用哪些工具 |
| 控制 | 开发者预定义每一步 | 开发者定义能力和工具，Agent 决定如何组合使用它们 |
| 输入 | 通常一次性输入 | 可以通过多轮交互/环境反馈不断调整行为 |
| 适用场景 | 任务明确、可拆解 | 开放式任务、不可预测、多轮迭代、需要自主决策 |
| 复杂度 | 可以直接画流程图、每步都确定 | 流程是动态生成的，可能无法画出完整图，开发重点在能力和接口设计 |


### 举个类比
> + Workflow：就像工厂流水线，你定义好每一步的工序和顺序。
    >     - 你告诉 LLM：“先生成摘要 → 再翻译 → 再检查”。
>     - 每一步都是固定的，开发时几乎可以画完整流程图。
> + Agent：就像一个自主员工，你告诉他：“你有工具 A、B、C，可以独立完成任务 X”。
    >     - 他自己决定先用工具 A 做什么，再用工具 B 做什么，如果遇到问题还能回头调整。
>     - 你无法提前画出完整流程图，因为 Agent 的每一步取决于 **实时输入和环境反馈**。
>

### 增强型的LLM
Agent 系统的基本构建模块是经过增强的大语言模型（LLM），这些增强包括检索、工具和记忆等功能。我们当前的模型可以主动使用这些功能——生成自己的搜索查询、选择合适的工具，并确定需要保留的信息。推荐使用 **Model Context Protocol。**

![](https://img.superkusch.fun/docs/202511121550891.png)

### 工作流：提示链式调用（Prompt Chaining）
提示链式调用将一个任务分解为一系列步骤，每次 LLM 调用都处理前一步的输出。你可以在任何中间步骤上添加程序化的检查（参见下图中的 "gate"），以确保过程仍然按预期进行。这中工作流方式非常适用于那些任务能够轻松且清晰地分解为固定子任务的情况。其主要目标是通过将每个 LLM 调用转化为更简单的任务，从而牺牲一些延迟以提高准确性。

![](https://img.superkusch.fun/docs/image.png)

### 工作流：路由（Routing）
路由对输入进行分类，并将其定向到专门的后续任务。该工作流允许分离关注点，并构建更专门的提示。

![](https://img.superkusch.fun/docs/202511121552439.png)

路由适用于复杂任务，其中有不同的类别，可以更好地单独处理，并且可以通过LLM或更传统的分类模型/算法准确地处理分类。

例子：

1. 将不同类型的客户服务查询（一般问题、退款请求、技术支持）引导到不同的下游流程、提示和工具。
2. 将简单/常见的问题转换为更小、更经济的模型，将困难/不寻常的问题转换为更强大的模型。

### 工作流：并行化（Parallelization）
llm有时可以同时处理一个任务，并以编程方式聚合其输出。这种工作流程，即并行化，表现为两种主要变体：

+ 分段（section）：将任务分解为独立的、并行运行的子任务。
+ 投票：多次运行相同的任务以获得不同的输出。

**分段（Sectioning）**

+ 安全防护：一个 LLM 处理用户的正常请求，另一个 LLM 同时检查是否有不当内容。这比让同一个 LLM 既处理请求又检查安全更有效。
+ 评估模型性能：评估一个模型时，每个 LLM 调用评估不同的指标（如准确性、逻辑性、可读性），而不是让一个 LLM 评估所有指标。

**投票（Voting）**

+ 代码审查：多次调用 LLM，用不同提示检查同一段代码的漏洞，如果有任何模型发现问题，就标记出来。
+ 内容审核：多次调用 LLM，用不同角度判断内容是否不当，再根据多次结果投票决定最终结果，减少误判或漏判。

![](https://img.superkusch.fun/docs/202511121552947.png)

### 工作流：协调者-工作者（Orchestrator-Workers）
在 **协调者-工作者** 工作流中，一个中央 LLM（协调者）会动态地将任务分解，委派给多个工作者 LLM 处理，然后综合它们的结果。

+ 协调者（Orchestrator）：就像一个项目经理，负责理解整个任务的目标、把任务拆分成子任务、分配给合适的“员工”去做，并最终整合各个子任务的结果。
+ 工作者（Workers）：就像不同的员工，各自负责执行分配给他们的具体任务。

> **与并行化的区别**
>
> + 并行化：子任务是 **预先定义好的**，只是同时运行提高速度或增加多样性。
    >     - 比如：任务是写一篇文章，分段并行写提纲和写正文，或者同一个文章让多个模型各写一次然后投票。
> + 协调者-工作者：子任务是 **动态生成的**，由协调者根据具体输入决定。
    >     - 比如：编程任务，你不知道需要改几个文件、每个文件改什么，协调者先分析，再把每个文件的修改任务分配给工作者。
>

![](https://img.superkusch.fun/docs/202511121553750.png)

**适用场景**

+ 高度复杂且不可预测的任务：子任务数量、内容和顺序都无法提前确定。
+ 需要动态决策：协调者根据输入实时生成子任务并管理执行。

**例子**：

1. 编程工具：一次需要修改多个文件，每个文件的修改内容不同。协调者决定哪些文件需要修改，每个工作者处理一个文件。
2. 信息检索任务：需要从多个来源收集信息并分析。协调者把不同来源或分析任务分配给不同的工作者，最后汇总结果。



### 工作流：评估者-优化者（Evaluator-Optimizer）
在 评估者-优化者 工作流中，一个 LLM 调用生成初步响应，而另一个 LLM 对其进行评估和反馈，并在循环中不断改进结果。

+ **生成者（Generator）**：先生成一个初步结果，就像写初稿。
+ **评估者（Evaluator）**：对初稿进行检查和反馈，就像编辑或者审阅者。

![](https://img.superkusch.fun/docs/202511121553289.png)

什么场景适合使用？

+ **任务需要精细优化**：初次生成的结果可能不够完美，需要反复改进。
+ **有明确标准**：有办法判断结果好坏，比如翻译是否准确、信息是否完整。
+ **迭代有价值**：每次修改都会显著提升结果的质量。

> 在 Evaluator-Optimizer（评估者-优化者） 工作流中：
>
> + 评估者不一定非得是 LLM，关键是它能够对生成结果提供反馈或评价。
> + 这意味着 用户也可以充当评估者，通过对话或人工反馈给生成者改进的建议。
> + 工作流的核心思想是 生成 → 评估 → 改进，无论评估环节是由 LLM 自动完成，还是由用户提供意见，本质都是循环迭代优化结果。
>
> 举个例子：
>
> 1. 初稿生成：LLM 写了一篇营销文案。
> 2. 评估反馈：用户阅读文案，给出改进意见（比如“语气更活泼一点”）。
> 3. 优化：LLM 根据用户反馈修改文案。
>
> 这个流程和 LLM 充当评估者的工作流形式完全一致，只是“评估者”由人工替代了模型。
>
> 不过这种方式在编程上有一定复杂度。
>

### <font style="color:rgb(20, 20, 19);background-color:rgb(250, 249, 245);">Agents</font>
Agents 的工作通常从 **接收人类用户的命令** 或 **与用户的互动讨论** 开始。一旦任务明确，Agents 可以独立规划和执行任务，并在需要进一步信息或判断时返回向人类请求。在执行过程中，Agents 必须在每一步从环境中获取 **“ground truth”**（例如工具调用结果或代码执行结果）来评估任务进展。Agents 也可以在检查点或遇到阻碍时暂停，等待人类反馈。任务通常在完成时终止，但也常设定**停止条件**（如最大迭代次数），以保持可控性。

![](https://img.superkusch.fun/docs/202511121553982.png)

Agents 更适用于 **开放式问题**，即难以或无法预测需要多少步骤，且无法通过硬编码固定路径完成的任务。LLM 可能需要执行多轮操作，因此你必须对其决策有一定信任。Agents 的自主性使它们非常适合在 **可信环境中扩展任务规模**。

+ Agents 的自主性意味着 **成本更高**，且存在 **复合错误的风险**。
+ 我们建议在 **沙盒环境中进行充分测试**，并设置适当的安全防护。

![](https://img.superkusch.fun/docs/202511121554324.png)

### 实践时怎么选择
前面介绍的工作流模式（如 Prompt Chaining、Routing、Parallelization、Orchestrator-Workers、Evaluator-Optimizer）和构建模块（增强型 LLM、Agents）**不是固定规则**。

它们只是一些 **常见的设计模式**，开发者可以根据任务需求灵活组合和调整。

成功完成任务的核心在于 **测量性能 + 迭代优化**：

+ 测量性能：先看系统运行结果是否达到预期（准确性、效率、成本等指标）。
+ 迭代优化：根据测量结果，调整组合方式或增加/减少复杂性。

> **意思是**：不要盲目追求复杂工作流或自主 Agent，如果简单方法就能解决问题，就不必增加复杂性。
>
